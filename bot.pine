// @version=6
indicator("Candle-Reader Dashboard - Phase 3 (Stable Final)", overlay=true, max_labels_count=500, max_lines_count=500)

// ===================== USER INPUTS =====================
tablePos       = input.string("Top Right", "Table Position", options=["Top Left","Top Right","Bottom Left","Bottom Right"])
tfList         = input.string("5,15,60", "Timeframes (comma-separated)")   // demo-friendly defaults
historyLength  = input.int(5, "History Length", minval=1, maxval=10)
showMarkers    = input.bool(true, "Show Chart Markers")
showLabels     = input.bool(true, "Show Marker Labels (L/S/Exit)")

// Filters toggles
useMACD   = input.bool(true, "Use MACD")
useRSI    = input.bool(true, "Use RSI")
useVOL    = input.bool(true, "Use Volume")
useTREND  = input.bool(true, "Use Trend Filter")
useATR    = input.bool(true, "Use ATR Gate")
useSR     = input.bool(true, "Use Support/Resistance (SR)")

// Filter params
rsiLen    = input.int(14, "RSI Length")
rsiBull   = input.float(55, "RSI Bull ≥")
rsiBear   = input.float(45, "RSI Bear ≤")
fastMACD  = input.int(12, "MACD Fast")
slowMACD  = input.int(26, "MACD Slow")
sigMACD   = input.int(9, "MACD Signal")
volLen    = input.int(20, "Volume SMA Length")
emaFast   = input.int(50, "Trend EMA Fast")
emaSlow   = input.int(200, "Trend EMA Slow")
atrLen    = input.int(14, "ATR Length")
atrSmooth = input.int(50, "ATR Smooth")
sweetMin  = input.float(0.8, "ATR Sweet Min")
sweetMax  = input.float(1.5, "ATR Sweet Max")
hardLow   = input.float(0.6, "ATR Hard Low")
hardHigh  = input.float(2.2, "ATR Hard High")

// SR anchor TFs (max 3 supported safely)
srAnchorsStr = input.string("15,30,60", "SR Anchor TFs (comma-separated)")
pivotLeft    = input.int(15, "Pivot Left Width")
pivotRight   = input.int(15, "Pivot Right Width")
srNearPct    = input.float(0.30, "SR ATR Near tolerance")
srBreakPct   = input.float(0.20, "SR ATR Break tolerance")
srRetestPct  = input.float(0.30, "SR ATR Retest tolerance")

// Weights
wCandle   = input.int(2, "Weight Candle", minval=0, maxval=5)
wMACD     = input.int(3, "Weight MACD", minval=0, maxval=5)
wRSI      = input.int(2, "Weight RSI", minval=0, maxval=5)
wVOL      = input.int(1, "Weight Volume", minval=0, maxval=5)
wTREND    = input.int(2, "Weight Trend", minval=0, maxval=5)
wSR       = input.int(2, "Weight SR", minval=0, maxval=5)
wATR      = input.int(1, "Weight ATR", minval=0, maxval=5)

// Demo-friendly relaxed thresholds (easy to trigger during demo)
T_entry   = input.float(0.5, "Entry Threshold (demo)")
Delta     = input.float(0.2, "Hysteresis Delta (demo)")
T_hold    = T_entry - Delta
T_exit    = T_entry - 2 * Delta

// ===================== PATTERN DETECTION (kept as functions) =====================
detectPattern(o,h,l,c) =>
    body     = math.abs(c - o)
    upperW   = h - math.max(c,o)
    lowerW   = math.min(c,o) - l
    rangeHL  = h - l + 1e-10
    bodyPct  = body / rangeHL
    pattern  = ""
    dir      = 0
    if bodyPct < 0.1
        pattern := "Doji"
        dir := 0
    else if bodyPct > 0.9
        pattern := c > o ? "MaruB" : "MaruS"
        dir := c > o ? +1 : -1
    else if (lowerW > 2 * body) and (upperW < body)
        pattern := "Hammer"
        dir := +1
    else if (upperW > 2 * body) and (lowerW < body)
        pattern := "Shooting"
        dir := -1
    else if bodyPct < 0.3
        pattern := "Spinning"
        dir := 0
    [pattern, dir]

detectEngulfing(o1,h1,l1,c1,o2,h2,l2,c2) =>
    bull = (c2 > o2) and (o1 > c1) and (c2 >= h1) and (o2 <= l1)
    bear = (o2 > c2) and (c1 > o1) and (o2 >= h1) and (c2 <= l1)
    [bull ? "BullE" : bear ? "BearE" : "", bull ? +1 : bear ? -1 : 0]

detectInside(h1,l1,h2,l2) =>
    inside = (h2 < h1) and (l2 > l1)
    [inside ? "Inside" : "", 0]

// ===================== TABLE SETUP =====================
pos = tablePos == "Top Left" ? position.top_left : tablePos == "Top Right" ? position.top_right : tablePos == "Bottom Left" ? position.bottom_left : position.bottom_right
var table dashTable = table.new(position=pos, columns=6, rows=20, border_width=1)

// show debug cell once so table is visible
if barstate.isfirst
    table.cell(dashTable, 0, 0, "DEBUG", bgcolor=color.orange, text_color=color.black)

// ===================== HISTORY MAP (safe init & clear) =====================
var string_map_keys = array.new_string(0)
var string_map_vals = array.new_string(0)
// Clear previous session stored content on first run to avoid historic overflow
if barstate.isfirst
    array.clear(string_map_keys)
    array.clear(string_map_vals)

map_set(k, v) =>
    found = false
    sz = array.size(string_map_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(string_map_keys, ii) == k
                array.set(string_map_vals, ii, v)
                found := true
                break
    if not found
        array.push(string_map_keys, k)
        array.push(string_map_vals, v)

map_get(k) =>
    res = ""
    sz = array.size(string_map_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(string_map_keys, ii) == k
                res := array.get(string_map_vals, ii)
                break
    res

// histPush returns two strings: stored (comma-separated short tokens), display (with arrows)
histPush(histStored, newTok) =>
    // if stored string present, split it; else start with empty array
    parts = str.length(histStored) > 0 ? str.split(histStored, ",") : array.new_string(0)
    parts_sz = array.size(parts)
    arr = array.new_string(0)
    if parts_sz > 0
        for i = 0 to parts_sz - 1
            tok = str.trim(array.get(parts, i))
            if str.length(tok) > 0
                array.push(arr, tok)
    // append newest token
    array.push(arr, newTok)
    // cap to historyLength to prevent runaway string size
    while array.size(arr) > historyLength
        array.shift(arr)
    // build stored and display strings
    stored = ""
    display = ""
    for i = 0 to array.size(arr) - 1
        t = array.get(arr, i)
        stored := stored == "" ? t : stored + "," + t
        display := display == "" ? t : display + " → " + t
    // return both safely
    [stored, display]

// ===================== SR anchors (explicit safe requests up-to-3 anchors) =====================
anchors = str.split(srAnchorsStr, ",")
anchorA = array.size(anchors) > 0 ? str.trim(array.get(anchors, 0)) : ""
anchorB = array.size(anchors) > 1 ? str.trim(array.get(anchors, 1)) : ""
anchorC = array.size(anchors) > 2 ? str.trim(array.get(anchors, 2)) : ""

// call request.security once per anchor (safe)
ph1 = anchorA != "" ? request.security(syminfo.tickerid, anchorA, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl1 = anchorA != "" ? request.security(syminfo.tickerid, anchorA, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
ph2 = anchorB != "" ? request.security(syminfo.tickerid, anchorB, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl2 = anchorB != "" ? request.security(syminfo.tickerid, anchorB, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
ph3 = anchorC != "" ? request.security(syminfo.tickerid, anchorC, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl3 = anchorC != "" ? request.security(syminfo.tickerid, anchorC, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na

levels = array.new_float(0)
types  = array.new_int(0)
array.clear(levels)
array.clear(types)
if not na(ph1)
    array.push(levels, ph1)
    array.push(types, 1)
if not na(pl1)
    array.push(levels, pl1)
    array.push(types, -1)
if not na(ph2)
    array.push(levels, ph2)
    array.push(types, 1)
if not na(pl2)
    array.push(levels, pl2)
    array.push(types, -1)
if not na(ph3)
    array.push(levels, ph3)
    array.push(types, 1)
if not na(pl3)
    array.push(levels, pl3)
    array.push(types, -1)

// ===================== MAIN LOOP (MTF rows) =====================
tfs = str.split(tfList, ",")
row = 1  // leave row 0 for DEBUG

for tf in tfs
    tf_str = str.trim(tf)
    if str.length(tf_str) == 0
        continue

    // fetch bundle for this TF
    [o,h,l,c,vol,o1,h1,l1,c1] = request.security(syminfo.tickerid, tf_str, [open, high, low, close, volume, open[1], high[1], low[1], close[1]], lookahead=barmerge.lookahead_off)

    // Patterns
    [pat1, dir1] = detectPattern(o,h,l,c)
    [patE, dirE] = detectEngulfing(o1,h1,l1,c1,o,h,l,c)
    [patI, dirI] = detectInside(h1,l1,h,l)
    patFinal = patE != "" ? patE : (patI != "" ? patI : pat1)
    dirCandle = patE != "" ? dirE : (patI != "" ? 0 : dir1)
    candleScore = dirCandle

    // --- inline filter calculations (unconditional) to avoid TV "call on each calculation" warnings ---
    // MACD
    macdLine = ta.ema(c, fastMACD) - ta.ema(c, slowMACD)
    macdSig  = ta.ema(macdLine, sigMACD)
    macdVal  = macdLine > macdSig ? +1 : macdLine < macdSig ? -1 : 0
    // RSI
    rsiValRaw = ta.rsi(c, rsiLen)
    rsiVal    = rsiValRaw >= rsiBull ? +1 : rsiValRaw <= rsiBear ? -1 : 0
    // Volume
    volSMA = ta.sma(vol, volLen)
    volVal = vol > volSMA ? +1 : -1
    // Trend
    trFast = ta.ema(c, emaFast)
    trSlow = ta.ema(c, emaSlow)
    trendVal = trFast > trSlow ? +1 : -1
    // ATR ratio
    atrNow = ta.atr(atrLen)
    atrSmoothVar = ta.sma(atrNow, atrSmooth)
    atrRatio = atrNow / (atrSmoothVar + 1e-10)
    atrVal = (atrRatio > hardHigh or atrRatio < hardLow) ? 0 : (atrRatio >= sweetMin and atrRatio <= sweetMax ? +1 : 0)

    // SRscore inline (nearest pivot by ATR-normalized dist vs this TF close 'c')
    srVal = 0
    baseATR = ta.atr(atrLen) + 1e-10
    if array.size(levels) > 0
        bestNorm = 1e12
        bestType = 0
        for j = 0 to array.size(levels) - 1
            lvl = array.get(levels, j)
            typ = array.get(types, j)
            if not na(lvl)
                norm = math.abs(c - lvl) / baseATR
                if norm < bestNorm
                    bestNorm := norm
                    bestType := typ
        if bestNorm != 1e12
            if bestNorm <= srBreakPct
                srVal := bestType == -1 ? +1 : -1
            else if bestNorm <= srNearPct
                srVal := bestType == -1 ? +1 : -1
            else if bestNorm <= srRetestPct
                srVal := 0
            else
                srVal := 0

    // apply toggles (scores)
    macdScore = useMACD ? macdVal : 0
    rsiScore  = useRSI ? rsiVal : 0
    volScore  = useVOL ? volVal : 0
    trendScore= useTREND ? trendVal : 0
    atrScore  = useATR ? atrVal : 0
    srScore   = useSR ? srVal : 0

    // N-of-M (MACD/RSI/Vol)
    corePass = (macdScore != 0 ? 1 : 0) + (rsiScore != 0 ? 1 : 0) + (volScore != 0 ? 1 : 0)
    nOfMok = corePass >= 2

    // Weighted score
    score = wCandle * candleScore + wMACD * macdScore + wRSI * rsiScore + wVOL * volScore + wTREND * trendScore + wSR * srScore + wATR * atrScore

    // Confidence normalization
    sumWeights = wCandle + wMACD + wRSI + wVOL + wTREND + wSR + wATR
    conf = sumWeights > 0 ? math.round(100 * (score + sumWeights) / (2 * sumWeights)) : 50
    conf := conf < 0 ? 0 : conf > 100 ? 100 : conf

    // State / hysteresis
    state = "Monitoring"
    if nOfMok
        if score >= T_entry
            state := "Entry Long"
        else if score <= -T_entry
            state := "Entry Short"
        else if score > T_hold
            state := "Long Running"
        else if score < -T_hold
            state := "Short Running"
        else if math.abs(score) <= T_exit
            state := "Exit"
    else
        state := "Blocked"

    // History (store small comma string, display with arrows)
    shortCode = patFinal == "" ? "—" : patFinal
    prevStored = map_get(tf_str)
    [newStored, displayHist] = histPush(prevStored, shortCode)
    map_set(tf_str, newStored)

    // Tooltips
    tt_hist = "History (→ newest): " + displayHist
    tt_current = "Pattern: " + patFinal
    tt_filters = "MACD:" + str.tostring(macdScore) + " RSI:" + str.tostring(rsiScore) + " VOL:" + str.tostring(volScore) + " SR:" + str.tostring(srScore)
    tt_signal = "Score:" + str.tostring(score) + " Conf:" + str.tostring(conf) + "%"

    // Table write (TF | History | Pattern | State | Filters | Confidence)
    table.cell(dashTable, 0, row, tf_str, bgcolor=color.gray, text_color=color.white)
    table.cell(dashTable, 1, row, displayHist, tooltip = tt_hist)
    table.cell(dashTable, 2, row, patFinal, tooltip = tt_current)
    table.cell(dashTable, 3, row, state, tooltip = tt_signal)
    table.cell(dashTable, 4, row, tt_filters, tooltip = tt_filters)
    bgC = conf >= 85 ? color.new(color.green, 60) : conf >= 70 ? color.new(color.green, 80) : conf >= 40 ? color.new(color.yellow, 80) : color.new(color.red, 80)
    table.cell(dashTable, 5, row, str.tostring(conf) + "%", bgcolor = bgC)

    // persistent markers (confirmed bars only)
    if showMarkers and barstate.isconfirmed
        if state == "Entry Long"
            label.new(bar_index, low, "▲" + (showLabels ? " L" : ""), style=label.style_label_up, color=color.green, textcolor=color.white, yloc=yloc.belowbar, size=size.small)
        else if state == "Entry Short"
            label.new(bar_index, high, "▼" + (showLabels ? " S" : ""), style=label.style_label_down, color=color.red, textcolor=color.white, yloc=yloc.abovebar, size=size.small)
        else if state == "Exit"
            label.new(bar_index, close, "■" + (showLabels ? " Exit" : ""), style=label.style_label_center, color=color.gray, textcolor=color.white, yloc=yloc.price, size=size.small)

    row += 1

// Footer (optional)
table.cell(dashTable, 0, row, "Config", bgcolor=color.silver)
table.cell(dashTable, 1, row, "Anchors:" + srAnchorsStr)
table.cell(dashTable, 2, row, "PivL/R:" + str.tostring(pivotLeft) + "/" + str.tostring(pivotRight))
table.cell(dashTable, 3, row, "Weights C/M/R:" + str.tostring(wCandle) + "/" + str.tostring(wMACD) + "/" + str.tostring(wRSI))
table.cell(dashTable, 4, row, "SRW:" + str.tostring(wSR))
table.cell(dashTable, 5, row, " ")

