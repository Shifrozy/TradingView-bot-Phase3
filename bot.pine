//@version=6
indicator("Candle-Reader Dashboard - Phase 3 (State Machine, Stable)", overlay=true, max_labels_count=500, max_lines_count=500)

// -------------------- INPUTS --------------------
tablePos       = input.string("Top Right", "Table Position", options=["Top Left","Top Right","Bottom Left","Bottom Right"])
tfList         = input.string("5,15,60", "Timeframes (comma-separated)")
historyLength  = input.int(5, "History Length", minval=1, maxval=20)
showMarkers    = input.bool(true, "Show Chart Markers")
showMarkersChartOnly = input.bool(true, "Only show markers for chart's TF")
showLabels     = input.bool(true, "Show Marker Labels (L/S/Exit)")

useMACD   = input.bool(true, "Use MACD")
useRSI    = input.bool(true, "Use RSI")
useVOL    = input.bool(true, "Use Volume")
useTREND  = input.bool(true, "Use Trend Filter")
useATR    = input.bool(true, "Use ATR Gate")
useSR     = input.bool(true, "Use Support/Resistance (SR)")

rsiLen    = input.int(14, "RSI Length")
rsiBull   = input.float(55, "RSI Bull ≥")
rsiBear   = input.float(45, "RSI Bear ≤")
fastMACD  = input.int(12, "MACD Fast")
slowMACD  = input.int(26, "MACD Slow")
sigMACD   = input.int(9, "MACD Signal")
volLen    = input.int(20, "Volume SMA Length")
emaFast   = input.int(50, "Trend EMA Fast")
emaSlow   = input.int(200, "Trend EMA Slow")
atrLen    = input.int(14, "ATR Length")
atrSmooth = input.int(50, "ATR Smooth")
sweetMin  = input.float(0.8, "ATR Sweet Min")
sweetMax  = input.float(1.5, "ATR Sweet Max")
hardLow   = input.float(0.6, "ATR Hard Low")
hardHigh  = input.float(2.2, "ATR Hard High")

srAnchorsStr = input.string("15,30,60", "SR Anchor TFs (comma-separated)")
pivotLeft    = input.int(15, "Pivot Left Width")
pivotRight   = input.int(15, "Pivot Right Width")
srNearPct    = input.float(0.30, "SR ATR Near tolerance")
srBreakPct   = input.float(0.20, "SR ATR Break tolerance")
srRetestPct  = input.float(0.30, "SR ATR Retest tolerance")

wCandle   = input.int(2, "Weight Candle", minval=0, maxval=5)
wMACD     = input.int(3, "Weight MACD", minval=0, maxval=5)
wRSI      = input.int(2, "Weight RSI", minval=0, maxval=5)
wVOL      = input.int(1, "Weight Volume", minval=0, maxval=5)
wTREND    = input.int(2, "Weight Trend", minval=0, maxval=5)
wSR       = input.int(2, "Weight SR", minval=0, maxval=5)
wATR      = input.int(1, "Weight ATR", minval=0, maxval=5)

T_entry   = input.float(0.5, "Entry Threshold")
Delta     = input.float(0.2, "Hysteresis Delta")
T_hold    = T_entry - Delta
T_exit    = T_entry - 2 * Delta
requireTrend = input.bool(true, "Require trend alignment for entries (EMA fast > slow)")
entryConfirmBars = input.int(2, "Confirm entry after N bars", minval=1, maxval=10)
minBarsBetweenSignals = input.int(2, "Min bars between opposite signals (flip guard)", minval=0, maxval=200)
confExitThreshold = input.int(30, "Confidence threshold to force exit (percent)")

// -------------------- PATTERN DETECTORS --------------------
detectPattern(o,h,l,c) =>
    body = math.abs(c - o)
    upperW = h - math.max(c,o)
    lowerW = math.min(c,o) - l
    rangeHL = h - l + 1e-10
    bodyPct = body / rangeHL
    pattern = ""
    dir = 0
    if bodyPct < 0.1
        pattern := "Doji"
        dir := 0
    else if bodyPct > 0.9
        pattern := c > o ? "MaruB" : "MaruS"
        dir := c > o ? +1 : -1
    else if (lowerW > 2 * body) and (upperW < body)
        pattern := "Hammer"
        dir := +1
    else if (upperW > 2 * body) and (lowerW < body)
        pattern := "Shooting"
        dir := -1
    else if bodyPct < 0.3
        pattern := "Spinning"
        dir := 0
    [pattern, dir]

detectEngulfing(o1,h1,l1,c1,o2,h2,l2,c2) =>
    bull = (c2 > o2) and (o1 > c1) and (c2 >= h1) and (o2 <= l1)
    bear = (o2 > c2) and (c1 > o1) and (o2 >= h1) and (c2 <= l1)
    [bull ? "BullE" : bear ? "BearE" : "", bull ? +1 : bear ? -1 : 0]

detectInside(h1,l1,h2,l2) =>
    inside = (h2 < h1) and (l2 > l1)
    [inside ? "Inside" : "", 0]

// -------------------- SAFE histPush --------------------
histPush(histStored, newTok) =>
    arr = array.new_string(0)
    if str.length(histStored) > 0
        parts = str.split(histStored, ",")
        parts_sz = array.size(parts)
        if parts_sz > 0
            for i = 0 to parts_sz - 1
                tok = str.trim(array.get(parts, i))
                if str.length(tok) > 0
                    array.push(arr, tok)
    array.push(arr, newTok)
    while array.size(arr) > historyLength
        array.shift(arr)
    stored = ""
    display = ""
    arr_sz = array.size(arr)
    if arr_sz > 0
        for i = 0 to arr_sz - 1
            t = array.get(arr, i)
            stored := stored == "" ? t : stored + "," + t
            display := display == "" ? t : display + " → " + t
    [stored, display]

// -------------------- MAP HELPERS (defensive) --------------------
// history map
var map_keys = array.new_string(0)
var map_vals = array.new_string(0)
if barstate.isfirst
    array.clear(map_keys)
    array.clear(map_vals)

map_set(k, v) =>
    found = false
    sz = array.size(map_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(map_keys, ii) == k
                array.set(map_vals, ii, v)
                found := true
                break
    if not found
        array.push(map_keys, k)
        array.push(map_vals, v)

map_get(k) =>
    res = ""
    sz = array.size(map_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(map_keys, ii) == k
                res := array.get(map_vals, ii)
                break
    res

// prev-score float map
var f_keys = array.new_string(0)
var f_vals = array.new_float(0)
if barstate.isfirst
    array.clear(f_keys)
    array.clear(f_vals)

map_set_float(k, v) =>
    found = false
    sz = array.size(f_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(f_keys, ii) == k
                array.set(f_vals, ii, v)
                found := true
                break
    if not found
        array.push(f_keys, k)
        array.push(f_vals, v)

map_get_float(k) =>
    res = 0.0
    sz = array.size(f_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(f_keys, ii) == k
                res := array.get(f_vals, ii)
                break
    res

// pending counters (int)
var int_keys_L = array.new_string(0)
var int_vals_L = array.new_int(0)
var int_keys_S = array.new_string(0)
var int_vals_S = array.new_int(0)
if barstate.isfirst
    array.clear(int_keys_L)
    array.clear(int_vals_L)
    array.clear(int_keys_S)
    array.clear(int_vals_S)

map_set_int(keysArr, valsArr, k, v) =>
    found = false
    sz = array.size(keysArr)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(keysArr, ii) == k
                array.set(valsArr, ii, v)
                found := true
                break
    if not found
        array.push(keysArr, k)
        array.push(valsArr, v)

map_get_int(keysArr, valsArr, k) =>
    res = 0
    sz = array.size(keysArr)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(keysArr, ii) == k
                if array.size(valsArr) > ii
                    res := array.get(valsArr, ii)
                break
    res

// last-signal map
var last_keys = array.new_string(0)
var last_bars = array.new_int(0)
var last_type = array.new_int(0)
if barstate.isfirst
    array.clear(last_keys)
    array.clear(last_bars)
    array.clear(last_type)

map_set_lastsig(k, baridx, t) =>
    found = false
    sz = array.size(last_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(last_keys, ii) == k
                array.set(last_bars, ii, baridx)
                array.set(last_type, ii, t)
                found := true
                break
    if not found
        array.push(last_keys, k)
        array.push(last_bars, baridx)
        array.push(last_type, t)

map_get_lastsig_bar(k) =>
    res = -999999
    sz = array.size(last_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(last_keys, ii) == k
                if array.size(last_bars) > ii
                    res := array.get(last_bars, ii)
                break
    res

map_get_lastsig_type(k) =>
    res = 0
    sz = array.size(last_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(last_keys, ii) == k
                if array.size(last_type) > ii
                    res := array.get(last_type, ii)
                break
    res

// state map (0=flat, 1=long, -1=short)
var state_keys = array.new_string(0)
var state_vals = array.new_int(0)
if barstate.isfirst
    array.clear(state_keys)
    array.clear(state_vals)

map_set_state(k, v) =>
    found = false
    sz = array.size(state_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(state_keys, ii) == k
                array.set(state_vals, ii, v)
                found := true
                break
    if not found
        array.push(state_keys, k)
        array.push(state_vals, v)

map_get_state(k) =>
    res = 0
    sz = array.size(state_keys)
    if sz > 0
        for ii = 0 to sz - 1
            if array.get(state_keys, ii) == k
                if array.size(state_vals) > ii
                    res := array.get(state_vals, ii)
                break
    res

// -------------------- TABLE INIT --------------------
pos = tablePos == "Top Left" ? position.top_left : tablePos == "Top Right" ? position.top_right : tablePos == "Bottom Left" ? position.bottom_left : position.bottom_right
var table dashTable = table.new(position=pos, columns=6, rows=40, border_width=1)
if barstate.isfirst
    table.cell(dashTable, 0, 0, "DEBUG", bgcolor=color.orange, text_color=color.black)

// -------------------- SR ANCHORS (safe requests) --------------------
anchors = str.split(srAnchorsStr, ",")
anchorA = array.size(anchors) > 0 ? str.trim(array.get(anchors, 0)) : ""
anchorB = array.size(anchors) > 1 ? str.trim(array.get(anchors, 1)) : ""
anchorC = array.size(anchors) > 2 ? str.trim(array.get(anchors, 2)) : ""

ph1 = anchorA != "" ? request.security(syminfo.tickerid, anchorA, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl1 = anchorA != "" ? request.security(syminfo.tickerid, anchorA, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
ph2 = anchorB != "" ? request.security(syminfo.tickerid, anchorB, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl2 = anchorB != "" ? request.security(syminfo.tickerid, anchorB, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
ph3 = anchorC != "" ? request.security(syminfo.tickerid, anchorC, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl3 = anchorC != "" ? request.security(syminfo.tickerid, anchorC, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na

levels = array.new_float(0)
types  = array.new_int(0)
if not na(ph1)
    array.push(levels, ph1)
    array.push(types, 1)
if not na(pl1)
    array.push(levels, pl1)
    array.push(types, -1)
if not na(ph2)
    array.push(levels, ph2)
    array.push(types, 1)
if not na(pl2)
    array.push(levels, pl2)
    array.push(types, -1)
if not na(ph3)
    array.push(levels, ph3)
    array.push(types, 1)
if not na(pl3)
    array.push(levels, pl3)
    array.push(types, -1)

// -------------------- MAIN LOOP --------------------
tfs = str.split(tfList, ",")
row = 1

for tf in tfs
    tf_str = str.trim(tf)
    if str.length(tf_str) == 0
        continue

    // MTF bundle (single request per TF)
    [o,h,l,c,vol,o1,h1,l1,c1] = request.security(syminfo.tickerid, tf_str, [open, high, low, close, volume, open[1], high[1], low[1], close[1]], lookahead=barmerge.lookahead_off)

    // patterns
    [pat1, dir1] = detectPattern(o,h,l,c)
    [patE, dirE] = detectEngulfing(o1,h1,l1,c1,o,h,l,c)
    [patI, dirI] = detectInside(h1,l1,h,l)
    patFinal = patE != "" ? patE : (patI != "" ? patI : pat1)
    candleScore = patE != "" ? dirE : (patI != "" ? 0 : dir1)

    // ===== all ta.* calculations (unconditional) =====
    macdLine = ta.ema(c, fastMACD) - ta.ema(c, slowMACD)
    macdSig  = ta.ema(macdLine, sigMACD)
    macdVal  = macdLine > macdSig ? +1 : macdLine < macdSig ? -1 : 0

    rsiRaw = ta.rsi(c, rsiLen)
    rsiVal = rsiRaw >= rsiBull ? +1 : rsiRaw <= rsiBear ? -1 : 0

    volSMA = ta.sma(vol, volLen)
    volVal = vol > volSMA ? +1 : -1

    trFast = ta.ema(c, emaFast)
    trSlow = ta.ema(c, emaSlow)
    trendVal = trFast > trSlow ? +1 : -1

    atrNow = ta.atr(atrLen)
    atrSmoothVar = ta.sma(atrNow, atrSmooth)
    atrRatio = atrNow / (atrSmoothVar + 1e-10)
    atrVal = (atrRatio > hardHigh or atrRatio < hardLow) ? 0 : (atrRatio >= sweetMin and atrRatio <= sweetMax ? +1 : 0)

    // SR scoring
    srVal = 0
    baseATR = ta.atr(atrLen) + 1e-10
    if array.size(levels) > 0
        localBest = 1e12
        localType = 0
        for j = 0 to array.size(levels) - 1
            lvl = array.get(levels, j)
            typ = array.get(types, j)
            if not na(lvl)
                norm = math.abs(c - lvl) / baseATR
                if norm < localBest
                    localBest := norm
                    localType := typ
        if localBest != 1e12
            if localBest <= srBreakPct
                srVal := localType == -1 ? +1 : -1
            else if localBest <= srNearPct
                srVal := localType == -1 ? +1 : -1
            else if localBest <= srRetestPct
                srVal := 0

    // gate toggles
    macdScore = useMACD ? macdVal : 0
    rsiScore  = useRSI ? rsiVal : 0
    volScore  = useVOL ? volVal : 0
    trendScore= useTREND ? trendVal : 0
    atrScore  = useATR ? atrVal : 0
    srScore   = useSR ? srVal : 0

    // core and weighted score
    corePass = (macdScore != 0 ? 1 : 0) + (rsiScore != 0 ? 1 : 0) + (volScore != 0 ? 1 : 0)
    nOfMok = corePass >= 2

    score = wCandle * candleScore + wMACD * macdScore + wRSI * rsiScore + wVOL * volScore + wTREND * trendScore + wSR * srScore + wATR * atrScore
    sumWeights = wCandle + wMACD + wRSI + wVOL + wTREND + wSR + wATR
    conf = sumWeights > 0 ? math.round(100 * (score + sumWeights) / (2 * sumWeights)) : 50
    conf_val = conf < 0 ? 0 : conf > 100 ? 100 : conf

    // ---------- SIGNAL HARDENING (pending counters/confirm) ----------
    prevScore = map_get_float(tf_str)

    rawLong = nOfMok and (score >= T_entry)
    rawShort = nOfMok and (score <= -T_entry)

    trendOkLong = (not requireTrend) or (trendScore == 1)
    trendOkShort = (not requireTrend) or (trendScore == -1)

    curLongCnt = map_get_int(int_keys_L, int_vals_L, tf_str)
    curShortCnt = map_get_int(int_keys_S, int_vals_S, tf_str)

    curLongCnt := (rawLong and trendOkLong) ? curLongCnt + 1 : 0
    curShortCnt := (rawShort and trendOkShort) ? curShortCnt + 1 : 0

    map_set_int(int_keys_L, int_vals_L, tf_str, curLongCnt)
    map_set_int(int_keys_S, int_vals_S, tf_str, curShortCnt)

    // last signal spacing guard
    lastBar = map_get_lastsig_bar(tf_str)
    lastType = map_get_lastsig_type(tf_str)
    barsSinceLast = (lastBar < 0) ? 999999 : (bar_index - lastBar)

    // confirmedSignal indicates candidate confirmed by pending count (still not the held-state machine)
    confirmedSignal = 0
    if curLongCnt >= math.max(1, entryConfirmBars)
        if barsSinceLast >= minBarsBetweenSignals or lastType != 1
            confirmedSignal := 1
    if curShortCnt >= math.max(1, entryConfirmBars)
        if barsSinceLast >= minBarsBetweenSignals or lastType != -1
            confirmedSignal := -1

    // ---------- STATE MACHINE (per TF) ----------------
    prevState = map_get_state(tf_str)  // 0 flat, 1 long, -1 short
    newState = prevState
    emitSignal = 0  // 1=long entry, -1=short entry, 2=exit

    // Entry transitions (only when candidate confirmed and not already in same state)
    if confirmedSignal == 1 and prevState != 1
        // allow entry if trend ok and spacing ok
        if (trendOkLong) and (barsSinceLast >= minBarsBetweenSignals or lastType != 1)
            newState := 1
            emitSignal := 1
            // register last signal
            map_set_lastsig(tf_str, bar_index, +1)

    if confirmedSignal == -1 and prevState != -1
        if (trendOkShort) and (barsSinceLast >= minBarsBetweenSignals or lastType != -1)
            newState := -1
            emitSignal := -1
            map_set_lastsig(tf_str, bar_index, -1)

    // Exit conditions while holding
    // Long held -> exit when score drops below T_exit OR opposite confirmed OR confidence collapse
    if newState == 1
        longExitCond = (score <= T_exit) or (curShortCnt >= math.max(1, entryConfirmBars)) or (conf_val <= confExitThreshold)
        if longExitCond
            newState := 0
            emitSignal := 2  // exit

    // Short held -> exit when score rises above -T_exit OR opposite confirmed OR confidence collapse
    if newState == -1
        shortExitCond = (score >= -T_exit) or (curLongCnt >= math.max(1, entryConfirmBars)) or (conf_val <= confExitThreshold)
        if shortExitCond
            newState := 0
            emitSignal := 2  // exit

    // persist new state
    if newState != prevState
        map_set_state(tf_str, newState)

    // update prevScore for next bar
    map_set_float(tf_str, score)

    // history push (safe)
    prevStored = map_get(tf_str)
    [newStored, displayHist] = histPush(prevStored, patFinal)
    map_set(tf_str, newStored)

    // table state display
    state_display = newState == 1 ? "Long (Held)" : newState == -1 ? "Short (Held)" : (curLongCnt > 0 ? "Pending L (" + str.tostring(curLongCnt) + ")" :  curShortCnt > 0 ? "Pending S (" + str.tostring(curShortCnt) + ")" : (nOfMok ? (math.abs(score) > T_hold ? (score > 0 ? "Long Running" : "Short Running") : "Monitoring") : "Blocked") )

    // tooltips & table writes
    tt_hist = "History (→ newest): " + displayHist
    tt_current = "Pattern: " + patFinal
    tt_filters = "MACD:" + str.tostring(macdScore) + " RSI:" + str.tostring(rsiScore) + " VOL:" + str.tostring(volScore) + " SR:" + str.tostring(srScore)
    tt_signal = "Score:" + str.tostring(score) + " Conf:" + str.tostring(conf_val) + "%"

    table.cell(dashTable, 0, row, tf_str, bgcolor=color.gray, text_color=color.white)
    table.cell(dashTable, 1, row, displayHist, tooltip = tt_hist)
    table.cell(dashTable, 2, row, patFinal, tooltip = tt_current)
    table.cell(dashTable, 3, row, state_display, tooltip = tt_signal)
    table.cell(dashTable, 4, row, tt_filters, tooltip = tt_filters)
    bgC = conf_val >= 85 ? color.new(color.green, 60) : conf_val >= 70 ? color.new(color.green, 80) : conf_val >= 40 ? color.new(color.yellow, 80) : color.new(color.red, 80)
    table.cell(dashTable, 5, row, str.tostring(conf_val) + "%", bgcolor = bgC)

    // Plot labels only on transition events (emitSignal) and confirmed exit
    if showMarkers and emitSignal != 0 and barstate.isconfirmed
        showHere = (not showMarkersChartOnly) or (tf_str == timeframe.period)
        if showHere
            if emitSignal == 1
                label.new(bar_index, low, "▲" + (showLabels ? " L" : ""), style=label.style_label_up, color=color.green, textcolor=color.white, yloc=yloc.belowbar, size=size.small)
            else if emitSignal == -1
                label.new(bar_index, high, "▼" + (showLabels ? " S" : ""), style=label.style_label_down, color=color.red, textcolor=color.white, yloc=yloc.abovebar, size=size.small)
            else if emitSignal == 2
                label.new(bar_index, close, "■" + (showLabels ? " Exit" : ""), style=label.style_label_center, color=color.gray, textcolor=color.white, yloc=yloc.price, size=size.small)

    row := row + 1

// footer
table.cell(dashTable, 0, row, "Config", bgcolor=color.silver)
table.cell(dashTable, 1, row, "Anchors:" + srAnchorsStr)
table.cell(dashTable, 2, row, "PivL/R:" + str.tostring(pivotLeft) + "/" + str.tostring(pivotRight))
table.cell(dashTable, 3, row, "Weights C/M/R:" + str.tostring(wCandle) + "/" + str.tostring(wMACD) + "/" + str.tostring(wRSI))
table.cell(dashTable, 4, row, "SRW:" + str.tostring(wSR))
table.cell(dashTable, 5, row, " ")

