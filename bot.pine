// @version=6
indicator("Candle-Reader Dashboard - Phase 3 (Final Fixed v2)", overlay=true, max_labels_count=500, max_lines_count=500)

// ===================== USER INPUTS =====================
tablePos       = input.string("Top Right", "Table Position", options=["Top Left","Top Right","Bottom Left","Bottom Right"])
tfList         = input.string("1,3,5,15,30,60,240", "Timeframes (comma-separated)")
historyLength  = input.int(5, "History Length", minval=3, maxval=10)
showMarkers    = input.bool(true, "Show Chart Markers")
showLabels     = input.bool(true, "Show Marker Labels (L/S/Exit)")

// Filters toggles
useMACD   = input.bool(true, "Use MACD")
useRSI    = input.bool(true, "Use RSI")
useVOL    = input.bool(true, "Use Volume")
useTREND  = input.bool(true, "Use Trend Filter")
useATR    = input.bool(true, "Use ATR Gate")
useSR     = input.bool(true, "Use Support/Resistance (SR)")

// Filter params
rsiLen    = input.int(14, "RSI Length")
rsiBull   = input.float(55, "RSI Bull ≥")
rsiBear   = input.float(45, "RSI Bear ≤")
fastMACD  = input.int(12, "MACD Fast")
slowMACD  = input.int(26, "MACD Slow")
sigMACD   = input.int(9, "MACD Signal")
volLen    = input.int(20, "Volume SMA Length")
emaFast   = input.int(50, "Trend EMA Fast")
emaSlow   = input.int(200, "Trend EMA Slow")
atrLen    = input.int(14, "ATR Length")
atrSmooth = input.int(50, "ATR Smooth")
sweetMin  = input.float(0.8, "ATR Sweet Min")
sweetMax  = input.float(1.5, "ATR Sweet Max")
hardLow   = input.float(0.6, "ATR Hard Low")
hardHigh  = input.float(2.2, "ATR Hard High")

// SR anchor TFs
srAnchorsStr = input.string("15,30,60", "SR Anchor TFs (comma-separated)")
pivotLeft    = input.int(15, "Pivot Left Width")
pivotRight   = input.int(15, "Pivot Right Width")
srNearPct    = input.float(0.30, "SR ATR Near tolerance")
srBreakPct   = input.float(0.20, "SR ATR Break tolerance")
srRetestPct  = input.float(0.30, "SR ATR Retest tolerance")

// Weights
wCandle   = input.int(2, "Weight Candle", minval=0, maxval=5)
wMACD     = input.int(3, "Weight MACD", minval=0, maxval=5)
wRSI      = input.int(2, "Weight RSI", minval=0, maxval=5)
wVOL      = input.int(1, "Weight Volume", minval=0, maxval=5)
wTREND    = input.int(2, "Weight Trend", minval=0, maxval=5)
wSR       = input.int(2, "Weight SR", minval=0, maxval=5)
wATR      = input.int(1, "Weight ATR", minval=0, maxval=5)

// Hysteresis
T_entry   = input.float(2.2, "Entry Threshold")
Delta     = input.float(0.4, "Hysteresis Delta")
T_hold    = T_entry - Delta
T_exit    = T_entry - 2 * Delta

// ===================== PATTERN DETECTION =====================
detectPattern(o,h,l,c) =>
    body     = math.abs(c - o)
    upperW   = h - math.max(c,o)
    lowerW   = math.min(c,o) - l
    rangeHL  = h - l + 1e-10
    bodyPct  = body / rangeHL
    pattern  = ""
    dir      = 0
    if bodyPct < 0.1
        pattern := "Doji"
        dir := 0
    else if bodyPct > 0.9
        pattern := c > o ? "MaruB" : "MaruS"
        dir := c > o ? +1 : -1
    else if (lowerW > 2 * body) and (upperW < body)
        pattern := "Hammer"
        dir := +1
    else if (upperW > 2 * body) and (lowerW < body)
        pattern := "Shooting"
        dir := -1
    else if bodyPct < 0.3
        pattern := "Spinning"
        dir := 0
    [pattern, dir]

detectEngulfing(o1,h1,l1,c1,o2,h2,l2,c2) =>
    bull = (c2 > o2) and (o1 > c1) and (c2 >= h1) and (o2 <= l1)
    bear = (o2 > c2) and (c1 > o1) and (o2 >= h1) and (c2 <= l1)
    [bull ? "BullE" : bear ? "BearE" : "", bull ? +1 : bear ? -1 : 0]

detectInside(h1,l1,h2,l2) =>
    inside = (h2 < h1) and (l2 > l1)
    [inside ? "Inside" : "", 0]

// ===================== FILTERS =====================
calcRSI(src,len) =>
    r = ta.rsi(src, len)
    r >= rsiBull ? +1 : r <= rsiBear ? -1 : 0

calcMACD(src) =>
    macd = ta.ema(src, fastMACD) - ta.ema(src, slowMACD)
    sig  = ta.ema(macd, sigMACD)
    macd > sig ? +1 : macd < sig ? -1 : 0

calcVOL(vol) =>
    smaVol = ta.sma(vol, volLen)
    vol > smaVol ? +1 : -1

calcTREND(c) =>
    f = ta.ema(c, emaFast)
    s = ta.ema(c, emaSlow)
    f > s ? +1 : -1

calcATRratio() =>
    a = ta.atr(atrLen)
    smooth = ta.sma(a, atrSmooth)
    ratio = a / (smooth + 1e-10)
    (ratio > hardHigh or ratio < hardLow) ? 0 : (ratio >= sweetMin and ratio <= sweetMax ? +1 : 0)

// ===================== TABLE =====================
pos = tablePos == "Top Left" ? position.top_left : tablePos == "Top Right" ? position.top_right : tablePos == "Bottom Left" ? position.bottom_left : position.bottom_right
var table dashTable = table.new(position=pos, columns=6, rows=100, border_width=1)

// ===================== HISTORY MAP =====================
var string_map_keys = array.new_string(0)
var string_map_vals = array.new_string(0)

map_set(k, v) =>
    found = false
    for ii = 0 to array.size(string_map_keys) - 1
        if array.get(string_map_keys, ii) == k
            array.set(string_map_vals, ii, v)
            found := true
            break
    if not found
        array.push(string_map_keys, k)
        array.push(string_map_vals, v)

map_get(k) =>
    res = ""
    for ii = 0 to array.size(string_map_keys) - 1
        if array.get(string_map_keys, ii) == k
            res := array.get(string_map_vals, ii)
            break
    res

histPush(hist, s) =>
    parts = str.split(hist, ",")
    arr = array.new_string(0)
    for i = 0 to array.size(parts) - 1
        part = str.trim(array.get(parts, i))
        if str.length(part) > 0
            array.push(arr, part)
    array.push(arr, s)
    while array.size(arr) > historyLength
        array.shift(arr)
    out = ""
    for i = 0 to array.size(arr) - 1
        out := out == "" ? array.get(arr, i) : out + " → " + array.get(arr, i)
    out

// ===================== SR ANCHORS (explicit calls) =====================
anchors = str.split(srAnchorsStr, ",")
anchorA = array.size(anchors) > 0 ? str.trim(array.get(anchors, 0)) : ""
anchorB = array.size(anchors) > 1 ? str.trim(array.get(anchors, 1)) : ""
anchorC = array.size(anchors) > 2 ? str.trim(array.get(anchors, 2)) : ""

// call request.security once per anchor (safe)
ph1 = anchorA != "" ? request.security(syminfo.tickerid, anchorA, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl1 = anchorA != "" ? request.security(syminfo.tickerid, anchorA, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
ph2 = anchorB != "" ? request.security(syminfo.tickerid, anchorB, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl2 = anchorB != "" ? request.security(syminfo.tickerid, anchorB, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
ph3 = anchorC != "" ? request.security(syminfo.tickerid, anchorC, ta.pivothigh(high, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na
pl3 = anchorC != "" ? request.security(syminfo.tickerid, anchorC, ta.pivotlow(low, pivotLeft, pivotRight), lookahead=barmerge.lookahead_off) : na

levels = array.new_float(0)
types  = array.new_int(0)
if not na(ph1)
    array.push(levels, ph1)
    array.push(types, 1)
if not na(pl1)
    array.push(levels, pl1)
    array.push(types, -1)
if not na(ph2)
    array.push(levels, ph2)
    array.push(types, 1)
if not na(pl2)
    array.push(levels, pl2)
    array.push(types, -1)
if not na(ph3)
    array.push(levels, ph3)
    array.push(types, 1)
if not na(pl3)
    array.push(levels, pl3)
    array.push(types, -1)

computeSRscore(levelsArr, typesArr, atrLenLocal) =>
    if array.size(levelsArr) == 0
        0
    else
        float baseATR = ta.atr(atrLenLocal) + 1e-10
        float bestNorm = 1e12
        int bestType = 0
        for j = 0 to array.size(levelsArr) - 1
            lvl = array.get(levelsArr, j)
            typ = array.get(typesArr, j)
            if not na(lvl)
                norm = math.abs(close - lvl) / baseATR
                if norm < bestNorm
                    bestNorm := norm
                    bestType := typ
        if bestNorm == 1e12
            0
        else
            if bestNorm <= srBreakPct
                bestType == -1 ? +1 : -1
            else if bestNorm <= srNearPct
                bestType == -1 ? +1 : -1
            else if bestNorm <= srRetestPct
                0
            else
                0

// ===================== MAIN LOOP =====================
tfs = str.split(tfList, ",")
row = 0

for tf in tfs
    tf_str = str.trim(tf)
    if str.length(tf_str) == 0
        continue

    // direct tuple passed to request.security (no arrow function)
    [o,h,l,c,vol,o1,h1,l1,c1] = request.security(syminfo.tickerid, tf_str, [open, high, low, close, volume, open[1], high[1], low[1], close[1]], lookahead=barmerge.lookahead_off)

    [pat1, dir1] = detectPattern(o,h,l,c)
    [patE, dirE] = detectEngulfing(o1,h1,l1,c1,o,h,l,c)
    [patI, dirI] = detectInside(h1,l1,h,l)
    patFinal = patE != "" ? patE : (patI != "" ? patI : pat1)
    dirCandle = patE != "" ? dirE : (patI != "" ? 0 : dir1)
    candleScore = dirCandle

    macdScore = useMACD ? calcMACD(c) : 0
    rsiScore  = useRSI ? calcRSI(c, rsiLen) : 0
    volScore  = useVOL ? calcVOL(vol) : 0
    trendScore= useTREND ? calcTREND(c) : 0
    atrScore  = useATR ? calcATRratio() : 0
    srScore   = useSR ? computeSRscore(levels, types, atrLen) : 0

    corePass = (macdScore != 0 ? 1 : 0) + (rsiScore != 0 ? 1 : 0) + (volScore != 0 ? 1 : 0)
    nOfMok = corePass >= 2

    score = wCandle * candleScore + wMACD * macdScore + wRSI * rsiScore + wVOL * volScore + wTREND * trendScore + wSR * srScore + wATR * atrScore
    sumWeights = wCandle + wMACD + wRSI + wVOL + wTREND + wSR + wATR
    conf = sumWeights > 0 ? math.round(100 * (score + sumWeights) / (2 * sumWeights)) : 50
    conf := conf < 0 ? 0 : conf > 100 ? 100 : conf

    state = "Monitoring"
    if nOfMok
        if score >= T_entry
            state := "Entry Long"
        else if score <= -T_entry
            state := "Entry Short"
        else if score > T_hold
            state := "Long Running"
        else if score < -T_hold
            state := "Short Running"
        else if math.abs(score) <= T_exit
            state := "Exit"
    else
        state := "Blocked"

    shortCode = patFinal == "" ? "—" : patFinal
    prevHist = map_get(tf_str)
    newHist = histPush(prevHist, shortCode)
    map_set(tf_str, newHist)

    // Table write
    table.cell(dashTable, 0, row, tf_str, bgcolor=color.gray, text_color=color.white)
    table.cell(dashTable, 1, row, newHist)
    table.cell(dashTable, 2, row, patFinal)
    table.cell(dashTable, 3, row, state)
    table.cell(dashTable, 4, row, "Score " + str.tostring(score))
    bgC = conf >= 85 ? color.new(color.green, 60) : conf >= 70 ? color.new(color.green, 80) : conf >= 40 ? color.new(color.yellow, 80) : color.new(color.red, 80)
    table.cell(dashTable, 5, row, str.tostring(conf) + "%", bgcolor=bgC)

    if showMarkers and barstate.isconfirmed
        if state == "Entry Long"
            label.new(bar_index, low, "▲" + (showLabels ? " L" : ""), style=label.style_label_up, color=color.green, textcolor=color.white, yloc=yloc.belowbar, size=size.small)
        else if state == "Entry Short"
            label.new(bar_index, high, "▼" + (showLabels ? " S" : ""), style=label.style_label_down, color=color.red, textcolor=color.white, yloc=yloc.abovebar, size=size.small)
        else if state == "Exit"
            label.new(bar_index, close, "■" + (showLabels ? " Exit" : ""), style=label.style_label_center, color=color.gray, textcolor=color.white, yloc=yloc.price, size=size.small)

    row += 1

// ===================== END =====================
